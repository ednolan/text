<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Rationale</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter 1. Boost.Text (Proposed)">
<link rel="up" href="../index.html" title="Chapter 1. Boost.Text (Proposed)">
<link rel="prev" href="../index/s20.html" title="Macro Index">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../index/s20.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_text__proposed_.rationale"></a><a class="link" href="rationale.html" title="Rationale">Rationale</a>
</h2></div></div></div>
<h4>
<a name="boost_text__proposed_.rationale.h0"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale._classname_alt__boost__text__text___code__phrase_role__identifier__text__phrase___code___classname____classname_alt__boost__text__rope___code__phrase_role__identifier__rope__phrase___code___classname__are_implicitly_convertible_from__code__phrase_role__keyword__char__phrase___phrase_role__keyword__const__phrase___phrase_role__special_____phrase___code__"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale._classname_alt__boost__text__text___code__phrase_role__identifier__text__phrase___code___classname____classname_alt__boost__text__rope___code__phrase_role__identifier__rope__phrase___code___classname__are_implicitly_convertible_from__code__phrase_role__keyword__char__phrase___phrase_role__keyword__const__phrase___phrase_role__special_____phrase___code__">text,
      rope
      Are Implicitly Convertible from <code class="computeroutput"><span class="keyword">char</span>
      <span class="keyword">const</span> <span class="special">*</span></code>.</a>
    </h4>
<p>
      I find that the syntactic overhead of bringing UDLs into scope and then using
      them to be too high in some cases. Aggregate initialization including string-like
      objects is one of those:
    </p>
<div class="table">
<a name="boost_text__proposed_.rationale.t0"></a><p class="title"><b>Table 1.9. Explicit vs. Implicit Conversion from `char const *`</b></p>
<div class="table-contents"><table class="table" summary="Explicit vs. Implicit Conversion from `char const *`">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Explicit
              </p>
            </th>
<th>
              <p>
                Implicit
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
</p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span><span class="special">,</span> <span class="number">3</span><span class="special">&gt;</span> <span class="special">=</span> <span class="special">{{</span> <span class="string">"foo"</span><span class="identifier">_t</span><span class="special">,</span> <span class="string">"bar"</span><span class="identifier">_t</span><span class="special">,</span> <span class="string">"baz"</span><span class="identifier">_t</span> <span class="special">}};</span>
</pre>
<p>
              </p>
            </td>
<td>
              <p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span><span class="special">,</span> <span class="number">3</span><span class="special">&gt;</span> <span class="special">=</span> <span class="special">{{</span> <span class="string">"foo"</span><span class="special">,</span> <span class="string">"bar"</span><span class="special">,</span> <span class="string">"baz"</span> <span class="special">}};</span>
</pre>
<p>
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      I find the implicit-conversion code much more natural.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h1"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.unicode_algorithm_tailoring"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.unicode_algorithm_tailoring">Unicode
      Algorithm Tailoring</a>
    </h4>
<p>
      The behavior of some of the Unicode algorithms is intended to be tailorable.
      Boost.Text provides customization of some of its Unicode algorithm implementations
      for this purpose. Some possible tailorings are not available.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Grapheme breaks are not tailorable, because they are fundamental to how
          a large part of Boost.Text operates; everyone must have the same sense
          of what a grapheme is for this to work.
        </li>
<li class="listitem">
          Word breaks are tailorable. The tailorings available via Boost.Text's word
          breaking API should be enough handle most of the shortcomings listed in
          the <a href="https://unicode.org/reports/tr29/#Word_Boundary_Rules" target="_top">word
          break notes in Unicode Text Segmention</a>. The shortcomings not covered
          by Boost.Text's API require dictionary lookups (very much out of scope)
          or extra code point properties (for breaking on script boundaries; also
          out of scope).
        </li>
<li class="listitem">
          Sentence breaks are not tailorable, because the suggested tailorings require
          a large amount of context, and possibly dictionary-style lookups.
        </li>
<li class="listitem">
          Line breaks are not tailorable, because all the suggested tailorings involve
          multiple modes of behavior (e.g. for Korean text) or dictionary lookups.
        </li>
<li class="listitem">
          For bidirectional ordering, Unicode lays out certain tailorings it refers
          to as <a href="https://unicode.org/reports/tr9/#Higher-Level_Protocols" target="_top">Higher
          Level Protocols</a>. Boost.Text directly supports HL1 and HL4. HL2
          is unsupported because it frankly doesn't seem very important. HL3 and
          HL5 can be accomplished by manually adding directional formatting characters
          or other desired code points to segments of text. HL6 is completely unsupported,
          because it also seems like a very low-frequency use case.
        </li>
</ul></div>
<h4>
<a name="boost_text__proposed_.rationale.h2"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.boost_text_does_not_use_allocators"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.boost_text_does_not_use_allocators">Boost.Text
      Does Not Use allocators</a>
    </h4>
<p>
      Allocators are too low gain for the cost they impose. How many <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code>
      template instantiations in the code bases of the world involve a non-default
      allocator? I would be surprised if it was as high as 1%. Allocators may once
      have served an important function, but in modern C++ are a perfect example
      of not sticking to "Don't pay for what you don't use."
    </p>
<p>
      As a concrete example, consider <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>.
      This is a type whose sole purpose is to manage the allocations and reallocations
      of a heap-allocated array for you. Its interface allows me, via its allocator
      template parameter, to change its behavior to be a stack-allocated array of
      fixed size, but with a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
      interface. This has a large impact on the properties of the type, the <code class="computeroutput"><span class="keyword">noexcept</span></code>-ness of and time complexity of <code class="computeroutput"><span class="identifier">swap</span><span class="special">()</span></code> to
      name just one. I don't consider this to be a feature of the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
      design, but a bug.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index/s20.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a>
</div>
</body>
</html>
