<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>The Unicode Layer</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="prev" href="the__v1__and__v2__namespaces__and_the_use_of_c__20_concepts.html" title="The v1 and v2 Namespaces, and the Use of C++20 Concepts">
<link rel="next" href="the_unicode_layer/encoding_and_normalization.html" title="Encoding and Normalization">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="the__v1__and__v2__namespaces__and_the_use_of_c__20_concepts.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="the_unicode_layer/encoding_and_normalization.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_text__proposed_.the_unicode_layer"></a><a class="link" href="the_unicode_layer.html" title="The Unicode Layer">The Unicode Layer</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="the_unicode_layer/encoding_and_normalization.html">Encoding
      and Normalization</a></span></dt>
<dt><span class="section"><a href="the_unicode_layer/text_segmentation.html">Text
      Segmentation</a></span></dt>
<dt><span class="section"><a href="the_unicode_layer/case_mapping.html">Case
      Mapping</a></span></dt>
<dt><span class="section"><a href="the_unicode_layer/collation.html">Collation</a></span></dt>
<dt><span class="section"><a href="the_unicode_layer/searching.html">Searching</a></span></dt>
<dt><span class="section"><a href="the_unicode_layer/bidirectional_text.html">Bidirectional
      Text</a></span></dt>
</dl></div>
<p>
      "Unicode is hard."
    </p>
<p>
      <span class="emphasis"><em><span class="bold"><strong>-- Everyone</strong></span></em></span>
    </p>
<p>
      Unicode is hard to implement; the algorithms are crazy. Even as a user of Unicode,
      it can be difficult to understand how one is supposed to use Unicode correctly.
      The <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
      layer types do much of what is described in this section, but nicely out of
      view. Unless you need to use many different normalization and/or encoding forms,
      feel free to skip those portions of this section.
    </p>
<p>
      A primary design goal of the Unicode layer of Boost.Text is usability. To that
      end, the data model is as simple as possible.
    </p>
<h4>
<a name="boost_text__proposed_.the_unicode_layer.h0"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.a_quick_unicode_primer"></a></span><a class="link" href="the_unicode_layer.html#boost_text__proposed_.the_unicode_layer.a_quick_unicode_primer">A
      Quick Unicode Primer</a>
    </h4>
<p>
      There are multiple encoding types defined in Unicode: UTF-8, UTF-16, and UTF-32.
      A <span class="emphasis"><em>code unit</em></span> is the lowest-level datum-type in your Unicode
      data. Examples are a <code class="computeroutput"><span class="keyword">char</span></code> in UTF-8
      and a <code class="computeroutput"><span class="identifier">uint32_t</span></code> in UTF-32. A
      <span class="emphasis"><em>code point</em></span> is a 32-bit integral value that represents
      a single Unicode value. Examples are U+0041 "A" "LATIN CAPITAL
      LETTER A" and U+0308 "&#168;" "COMBINING DIAERESIS".
    </p>
<p>
      There are four different Unicode normalization forms. Normalization is necessary
      because Unicode requires that certain combinations of code points be considered
      identical. For instance, the two code points mentioned above, U+0041 U+0308,
      appear like this: "A&#776;", and the code point U+00C4 appears like this:
      "A&#776;". Since these two sequences are not visually distinct, all the
      algorithms must treat them as the same thing. Therefore, <code class="computeroutput"><span class="identifier">u8</span><span class="string">"\U00000041\U00000308"</span> <span class="special">==</span>
      <span class="identifier">u8</span><span class="string">"\U000000C4"</span></code>
      must evaluate to <code class="computeroutput"><span class="keyword">true</span></code> for the
      purposes of Unicode. Normalizations exist to put strings of code points into
      canonical forms that can be bitwise compared.
    </p>
<p>
      An <span class="emphasis"><em>extended grapheme cluster</em></span>, or just <span class="emphasis"><em>grapheme</em></span>,
      is a sequence of code points that appears to the end-user to be a single character.
      For example, the code points (U+0041 U+0308) form a grapheme, since they appear
      when rendered to be the single character "A&#776;".
    </p>
<h4>
<a name="boost_text__proposed_.the_unicode_layer.h1"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.unicode_versions"></a></span><a class="link" href="the_unicode_layer.html#boost_text__proposed_.the_unicode_layer.unicode_versions">Unicode
      Versions</a>
    </h4>
<p>
      There are multiple versions of Unicode, and Boost.Text only supports one at
      a time. There are large volumes of data required to implement the Unicode algorithms,
      and adding data for N versions of Unicode would make an already large library
      larger by a factor of N.
    </p>
<p>
      Most Unicode data used in Boost.Text come straight from the published Unicode
      data files, but the collation data are taken from <a href="http://cldr.unicode.org" target="_top">CLDR</a>,
      with language-specific tailoring data taken from <a href="https://unicode.org/reports/tr35/tr35-collation.html" target="_top">LDML</a>
      (a part of the <a href="http://cldr.unicode.org" target="_top">CLDR</a> project).
    </p>
<p>
      To find out what versions of Unicode and <a href="http://cldr.unicode.org" target="_top">CLDR</a>
      were used to generate Boost.Text's data, call <code class="computeroutput">unicode_version</code> or <code class="computeroutput">cldr_version</code>,
      respectively.
    </p>
<h4>
<a name="boost_text__proposed_.the_unicode_layer.h2"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.unicode_layer_parameter_conventions"></a></span><a class="link" href="the_unicode_layer.html#boost_text__proposed_.the_unicode_layer.unicode_layer_parameter_conventions">Unicode
      Layer Parameter Conventions</a>
    </h4>
<p>
      Most of the Unicode layer algorithms are written as typical C++ standard algorithms;
      they take iterators as input and produce output via an out-iterator. Since
      ranges are the future, there are range overloads of the algorithms that take
      a pair of iterators. The Unicode algorithms all operate on code points, so
      they take <a class="link" href="concepts.html" title="Concepts">CPIter</a> iterator
      parameters. The range overloads take <a class="link" href="concepts.html" title="Concepts">CPRange</a>
      parameters. For convenience, overloads are provided for many of the Unicode
      layer algorithms that take <a class="link" href="concepts.html" title="Concepts">GraphemeRange</a>
      and <a class="link" href="concepts.html" title="Concepts">GraphemeIterator</a>
      parameters. This provides convenient compatibility with the text layer types,
      like <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>.
    </p>
<p>
      Many of the algorithms and other functions accept null-terminated pointers,
      and treat them as ranges. This is done to make calling them with string literals
      and other null-terminated strings easier. A null terminated string <code class="computeroutput"><span class="identifier">s</span></code> is isomorphic with the range <code class="computeroutput"><span class="special">[</span><span class="identifier">s</span><span class="special">,</span>
      <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">null_sentinel</span><span class="special">{})</span></code>, and this is what Boost.Text's functions
      treat null-terminated strings as internally.
    </p>
<h4>
<a name="boost_text__proposed_.the_unicode_layer.h3"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.memory_allocations"></a></span><a class="link" href="the_unicode_layer.html#boost_text__proposed_.the_unicode_layer.memory_allocations">Memory
      Allocations</a>
    </h4>
<p>
      Many of the Unicode algorithms require that intermediate results be accumulated
      in side buffers at various times during their operation. Therefore, many of
      the algorithms in this section may allocate memory. However, Boost.Text makes
      extensive use of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">::</span><span class="identifier">small_vector</span><span class="special">&lt;&gt;</span></code>s
      for these side buffers. The end result is that though these algorithms <span class="emphasis"><em>may</em></span>
      allocate memory, in practice they seldom do, if ever.
    </p>
<h4>
<a name="boost_text__proposed_.the_unicode_layer.h4"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.what_about_code_point_properties_"></a></span><a class="link" href="the_unicode_layer.html#boost_text__proposed_.the_unicode_layer.what_about_code_point_properties_">What
      About Code Point Properties?</a>
    </h4>
<p>
      You might notice that there are no interfaces in this layer that provide properties
      of code points, like whether a particular code point is space or punctuation.
      The reason for this is that such properties are complicated in Unicode.
    </p>
<p>
      Unicode defines properties like space and punctuation, but it defines them
      in a highly context-sensitive way; each algorithm has its own set of properties
      it associates with code points. For instance, the word breaking algorithm is
      concerned with single quotes and double quotes, and so has a property for each,
      but other punctuation is spread out among its other properties. It has no property
      that maps to something like "punctuation" in a general sense.
    </p>
<p>
      So if you want to know if a code point is whitespace or not, you might have
      to look it up on a Unicode reference website (and implement a function for
      yourself), or see if the whitespace code points covered by one of the Unicode
      algorithms fits your needs and use that algorithm's <code class="computeroutput"><span class="special">*</span><span class="identifier">_prop</span><span class="special">()</span></code> function
      (e.g. <code class="computeroutput">word_prop</code>).
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="the__v1__and__v2__namespaces__and_the_use_of_c__20_concepts.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="the_unicode_layer/encoding_and_normalization.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
