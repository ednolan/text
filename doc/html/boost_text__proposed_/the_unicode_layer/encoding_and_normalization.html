<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Encoding and Normalization</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="up" href="../the_unicode_layer.html" title="The Unicode Layer">
<link rel="prev" href="../the_unicode_layer.html" title="The Unicode Layer">
<link rel="next" href="text_segmentation.html" title="Text Segmentation">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../the_unicode_layer.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../the_unicode_layer.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="text_segmentation.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization"></a><a class="link" href="encoding_and_normalization.html" title="Encoding and Normalization">Encoding
      and Normalization</a>
</h3></div></div></div>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h0"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_iterators"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_iterators">Transcoding
        Iterators</a>
      </h5>
<p>
        Boost.Text provides conversions among the UTF-8, UTF-16, and UTF-32 encodings,
        via converting iterators. The conversion among UTF encoding formats is referred
        to as transcoding. The converting iterators are:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/utf_8_to_16_iterator.html" title="Struct template utf_8_to_16_iterator">utf_8_to_16_iterator</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/utf_16_to_8_iterator.html" title="Struct template utf_16_to_8_iterator">utf_16_to_8_iterator</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/utf_16_to_32_iterator.html" title="Struct template utf_16_to_32_iterator">utf_16_to_32_iterator</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/utf_32_to_8_iterator.html" title="Struct template utf_32_to_8_iterator">utf_32_to_8_iterator</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/utf_32_to_16_iterator.html" title="Struct template utf_32_to_16_iterator">utf_32_to_16_iterator</a></code>
          </li>
</ul></div>
<p>
        There are three make-functions that create these transcoding iterators:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/v1/utf8_iterator_idm22891.html" title="Function template utf8_iterator">utf8_iterator()</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/v1/utf16_iterator_idm22908.html" title="Function template utf16_iterator">utf16_iterator()</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/v1/utf32_iterator_idm22925.html" title="Function template utf32_iterator">utf32_iterator()</a></code>
          </li>
</ul></div>
<p>
        A make-function is provided for each to-encoding; <code class="computeroutput"><span class="identifier">utf16_iterator</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
        <span class="identifier">b</span><span class="special">,</span> <span class="identifier">c</span><span class="special">)</span></code> returns:
        a <code class="computeroutput"><a class="link" href="../../boost/text/utf_8_to_16_iterator.html" title="Struct template utf_8_to_16_iterator">utf_8_to_16_iterator</a></code>
        if <code class="computeroutput"><span class="identifier">a</span></code>, <code class="computeroutput"><span class="identifier">b</span></code>,
        and <code class="computeroutput"><span class="identifier">c</span></code> are iterators to UTF-8
        code units; a <code class="computeroutput"><a class="link" href="../../boost/text/utf_32_to_16_iterator.html" title="Struct template utf_32_to_16_iterator">utf_32_to_16_iterator</a></code> if <code class="computeroutput"><span class="identifier">a</span></code>, <code class="computeroutput"><span class="identifier">b</span></code>,
        and <code class="computeroutput"><span class="identifier">c</span></code> are iterators to UTF-32
        code units (i.e. code points); and <code class="computeroutput"><span class="identifier">b</span></code>
        otherwise. See the section on <a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.iterator__quot_unpacking_quot_">iterator
        unpacking</a> for details.
      </p>
<p>
        By default, the transcoding iterators produce the Unicode replacement character
        <code class="computeroutput"><span class="number">0xFFFD</span></code> when encountering an invalid
        encoding. The exact error handling behavior can be controlled via the <code class="computeroutput"><span class="identifier">ErrorHandler</span></code> template parameter.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The error handling strategy of producing replacement characters is used
          exclusively within Boost.Text when performing conversions.
        </p></td></tr>
</table></div>
<p>
        The Unicode standard is flexible with respect to where, in an incoming stream,
        encoding errors are reported. However, the standard provides recommendations
        for where within a stream, and how frequently within that stream, errors
        should be reported. Boost.Text's converting iterators follow the Unicode
        recommendations. See Unicode, "Best Practices for Using U+FFFD"
        and Table 3-8.
      </p>
<p>
        The converting iterators are pretty straightforward, but there is an important
        caveat. Because each of these converting iterators does a substantial amount
        of work in increment and decrement operations, including in some cases caching
        the result of reading several bytes of a multi-byte encoding, post-increment
        and post-decrement can be quite a bit more expensive than pre-increment and
        pre-decrement.
      </p>
<p>
        To use a converting iterator, you must provide it with an underlying iterator.
        An example of use:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">uint32_t</span> <span class="keyword">const</span> <span class="identifier">utf32</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span><span class="number">0x004d</span><span class="special">,</span> <span class="number">0x0430</span><span class="special">,</span> <span class="number">0x4e8c</span><span class="special">,</span> <span class="number">0x10302</span><span class="special">};</span>
<span class="keyword">char</span> <span class="keyword">const</span> <span class="identifier">utf8</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span>
    <span class="number">0x4d</span><span class="special">,</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xd0</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xb0</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xe4</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xba</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0x8c</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xf0</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0x90</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0x8c</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0x82</span><span class="special">)};</span>
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf32_iterator</span><span class="special">(</span>
              <span class="identifier">std</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span><span class="identifier">utf8</span><span class="special">),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span><span class="identifier">utf8</span><span class="special">),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">end</span><span class="special">(</span><span class="identifier">utf8</span><span class="special">)),</span>
          <span class="identifier">end</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf32_iterator</span><span class="special">(</span>
              <span class="identifier">std</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span><span class="identifier">utf8</span><span class="special">),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">end</span><span class="special">(</span><span class="identifier">utf8</span><span class="special">),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">end</span><span class="special">(</span><span class="identifier">utf8</span><span class="special">));</span>
     <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span>
     <span class="special">++</span><span class="identifier">it</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">uint32_t</span> <span class="identifier">cp</span> <span class="special">=</span> <span class="special">*</span><span class="identifier">it</span><span class="special">;</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">cp</span> <span class="special">==</span> <span class="identifier">utf32</span><span class="special">[</span><span class="identifier">i</span><span class="special">++]);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        That's a lot of typing, so there's also a much terser range-based form using
        <code class="computeroutput"><a class="link" href="../../boost/text/utf32_view.html" title="Struct template utf32_view">utf32_view</a></code>:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">uint32_t</span> <span class="keyword">const</span> <span class="identifier">utf32</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span><span class="number">0x004d</span><span class="special">,</span> <span class="number">0x0430</span><span class="special">,</span> <span class="number">0x4e8c</span><span class="special">,</span> <span class="number">0x10302</span><span class="special">};</span>
<span class="keyword">char</span> <span class="keyword">const</span> <span class="identifier">utf8</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span>
    <span class="number">0x4d</span><span class="special">,</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xd0</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xb0</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xe4</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xba</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0x8c</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xf0</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0x90</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0x8c</span><span class="special">),</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0x82</span><span class="special">)};</span>
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">cp</span> <span class="special">:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">(</span><span class="identifier">utf8</span><span class="special">))</span> <span class="special">{</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">cp</span> <span class="special">==</span> <span class="identifier">utf32</span><span class="special">[</span><span class="identifier">i</span><span class="special">++]);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        All the transcoding iterators are bidirectional. When each one is dereferenced,
        it may read multiple values from the underlying input range. For instance,
        a <code class="computeroutput"><span class="identifier">utf_8_to_32_iterator</span> <span class="identifier">it</span></code>
        has to read 1-4 code units to produce a code point when performing the operation
        <code class="computeroutput"><span class="special">*</span><span class="identifier">it</span></code>.
        Therefore, each of these iterators requires the endpoints of the underlying
        range, to ensure that reads outside the underlying range generate replacement
        characters instead of undefined behavior.
      </p>
<p>
        All the transcoding iterators still exhibit undefined behavior when incrementing
        past the end of, or decrementing before the beginning of, the underlying
        range. The generation of replacment characters only happens in cases where
        the number of code units is variable and there is an incomplete sequence
        of code units right at the beginning or end.
      </p>
<p>
        For instance, if you have a sequence of UTF-8 that consists of a single broken
        code point sequence:
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// That the full UTF-8 encoding for U+8D00 is 0xe8, 0xb4, 0x80.</span>
<span class="keyword">char</span> <span class="keyword">const</span> <span class="identifier">broken_utf8_for_0x8d00</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span>
    <span class="keyword">char</span><span class="special">(</span><span class="number">0xe8</span><span class="special">),</span> <span class="keyword">char</span><span class="special">(</span><span class="number">0xb4</span><span class="special">)</span> <span class="comment">/* Incomplete! */</span><span class="special">};</span>
<span class="keyword">auto</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf32_iterator</span><span class="special">(</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span><span class="identifier">broken_utf8_for_0x8d00</span><span class="special">),</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span><span class="identifier">broken_utf8_for_0x8d00</span><span class="special">),</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">end</span><span class="special">(</span><span class="identifier">broken_utf8_for_0x8d00</span><span class="special">));</span>

<span class="identifier">assert</span><span class="special">(*</span><span class="identifier">it</span> <span class="special">==</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">replacement_character</span><span class="special">());</span>

<span class="comment">// --it; // Undefined behavior!</span>
<span class="special">++</span><span class="identifier">it</span><span class="special">;</span> <span class="comment">// Ok.  Incrementing through a broken sequence is defined.</span>
<span class="comment">// ++it; // Undefined behavior!  A subsequent increment past the end is not defined.</span>

<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        then <code class="computeroutput"><span class="special">*</span><span class="identifier">it</span></code>
        will produce a replacement character, and the behavior of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">next</span><span class="special">(</span><span class="identifier">it</span><span class="special">)</span></code>
        is defined. However, the behaviors of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">prev</span><span class="special">(</span><span class="identifier">it</span><span class="special">)</span></code>
        and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">next</span><span class="special">(</span><span class="identifier">it</span><span class="special">,</span> <span class="number">2</span><span class="special">)</span></code>
        are each undefined.
      </p>
<p>
        In keeping with the ranges and algorithms from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ranges</span></code>,
        the transcoding iterators accept an underlying input range that may be delimited
        by different types: the range is represented as an iterator-sentinel pair,
        instead of a pair of iterators. Boost.Text provides a null-terminated string
        sentinel, <code class="computeroutput"><a class="link" href="../../boost/text/null_sentinel_t.html" title="Struct null_sentinel_t">null_sentinel_t</a></code>,
        which can be used to represent a null-terminated string as a pointer-<code class="computeroutput"><a class="link" href="../../boost/text/null_sentinel_t.html" title="Struct null_sentinel_t">null_sentinel_t</a></code>
        pair.
      </p>
<p>
        Each transcoding iterator contains three elements: the <code class="computeroutput"><span class="special">[</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">)</span></code> of
        the underlying range, and the current position within that range. In the
        worst case, a transcoding iterator is the size of three pointers. If the
        underlying range is end-delimited by a <code class="computeroutput"><a class="link" href="../../boost/text/null_sentinel_t.html" title="Struct null_sentinel_t">null_sentinel_t</a></code>, it may be
        a bit smaller.
      </p>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h1"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_output_iterators"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_output_iterators">Transcoding
        Output Iterators</a>
      </h5>
<p>
        There are output iterator adapters for each of the iterators above. For each
        transcoding iterator <code class="computeroutput"><span class="identifier">utf_N_to_M_iterator</span></code>,
        there is are these iterators (and their associated functions):
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><span class="identifier">utf_N_to_M_out_iterator</span></code>
            - This is an adapting iterator that accepts UTF-<code class="computeroutput"><span class="identifier">N</span></code>
            values and writes values of type UTF-<code class="computeroutput"><span class="identifier">M</span></code>
            to an underlying output iterator. Each write to this iterator may write
            multiple values to the underlying iterator, depending on <code class="computeroutput"><span class="identifier">N</span></code> and <code class="computeroutput"><span class="identifier">M</span></code>.
            You can create one using <code class="computeroutput"><span class="identifier">utf_N_to_M_out</span></code>.
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">utf_N_to_M_insert_iterator</span></code>
            - This is analogous to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">insert_iterator</span></code>,
            but also does UTF-<code class="computeroutput"><span class="identifier">N</span></code> to
            UTF-<code class="computeroutput"><span class="identifier">M</span></code> transcoding. You
            can create one using <code class="computeroutput"><span class="identifier">from_utfN_inserter</span></code>;
            <code class="computeroutput"><span class="identifier">M</span></code> is deduced from the
            size of the <code class="computeroutput"><span class="identifier">value_type</span></code>
            of the container.
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">utf_N_to_M_front_insert_iterator</span></code>
            - This is analogous to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">front_insert_iterator</span></code>,
            but also does UTF-<code class="computeroutput"><span class="identifier">N</span></code> to
            UTF-<code class="computeroutput"><span class="identifier">M</span></code> transcoding. You
            can create one using <code class="computeroutput"><span class="identifier">from_utfN_front_inserter</span></code>;
            <code class="computeroutput"><span class="identifier">M</span></code> is deduced from the
            size of the <code class="computeroutput"><span class="identifier">value_type</span></code>
            of the container.
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">utf_N_to_M_back_insert_iterator</span></code>
            - This is analogous to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">back_insert_iterator</span></code>,
            but also does UTF-<code class="computeroutput"><span class="identifier">N</span></code> to
            UTF-<code class="computeroutput"><span class="identifier">M</span></code> transcoding. You
            can create one using <code class="computeroutput"><span class="identifier">from_utfN_back_inserter</span></code>;
            <code class="computeroutput"><span class="identifier">M</span></code> is deduced from the
            size of the <code class="computeroutput"><span class="identifier">value_type</span></code>
            of the container.
          </li>
</ul></div>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h2"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_iterator_performance"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_iterator_performance">Transcoding
        Iterator Performance</a>
      </h5>
<p>
        The transcoding iterators are available for flexibility. In particular, they
        can be used with the standard algorithms. However, this flexibility comes
        at a cost. When doing a bulk-transcoding operation, using these iterators
        can be substantially slower than using the transcoding algorithms.
      </p>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h3"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_views"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_views">Transcoding
        Views</a>
      </h5>
<p>
        Using transcoding iterators directly is a bit verbose and tedious. Also,
        when you use two transcoding iterators as an iterator pair, it may be the
        size of 6 underlying itertors!
      </p>
<p>
        So, both for convenience and for size optimization, Boost.Text provides view
        templates for UTF-8, UTF-16, and UTF-32: <code class="computeroutput"><a class="link" href="../../boost/text/utf8_view.html" title="Struct template utf8_view">utf8_view</a></code>, <code class="computeroutput"><a class="link" href="../../boost/text/utf16_view.html" title="Struct template utf16_view">utf16_view</a></code>, and <code class="computeroutput"><a class="link" href="../../boost/text/utf32_view.html" title="Struct template utf32_view">utf32_view</a></code>,
        respectively. Just as with the transcoding iterators, each view can be constructed
        from a pair of iterators or as an iterator-sentinel pair.
      </p>
<p>
        Make-functions <code class="computeroutput">as_utf8()</code>, <code class="computeroutput">as_utf16()</code>,
        and <code class="computeroutput">as_utf32()</code>, are also provided. The
        <code class="computeroutput"><span class="identifier">as_utfN</span><span class="special">()</span></code>
        functions are overloaded to take an iterator and sentinel, or a range:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span> <span class="special">=</span> <span class="string">"some text"</span><span class="special">;</span>

<span class="comment">// These each represent the same range:</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">utf32_range_the_hard_way</span> <span class="special">=</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf32_view</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">&gt;(</span><span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">utf32_range_from_utf8_range</span> <span class="special">=</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">(</span><span class="identifier">str</span><span class="special">);</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">utf32_range_from_utf8_iters</span> <span class="special">=</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">(</span><span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">utf32_range_from_utf8_iter_and_sentinel</span> <span class="special">=</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">(</span><span class="identifier">str</span><span class="special">.</span><span class="identifier">c_str</span><span class="special">(),</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">null_sentinel</span><span class="special">);</span>
</pre>
<p>
        These functions also support null-terminated strings; you can just pass a
        pointer to <code class="computeroutput"><span class="identifier">as_utfN</span><span class="special">()</span></code>:
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">range_1</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">(</span><span class="string">"text"</span><span class="special">);</span>         <span class="comment">// char const *</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">range_2</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">(</span><span class="identifier">u8</span><span class="string">"more text"</span><span class="special">);</span>  <span class="comment">// char8_t const *, in C++20 and later</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">range_3</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">(</span><span class="identifier">u16</span><span class="string">"more text"</span><span class="special">);</span> <span class="comment">// char16_t const *</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">range_4</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">(</span><span class="identifier">u32</span><span class="string">"more text"</span><span class="special">);</span> <span class="comment">// char32_t const *</span>
</pre>
<p>
        You can pass any range of 1-, 2-, or 4-byte integral values to <code class="computeroutput"><span class="identifier">as_utfN</span><span class="special">()</span></code>,
        and you will get a range that transcodes from UTF-8, UTF-16, or UTF-32 to
        UTF-<code class="computeroutput"><span class="identifier">N</span></code>, respectively.
      </p>
<p>
        The views are all streamable. They transcode to UTF-8 when streamed to a
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span></code>,
        and they transcode to UTF-16 when streamed to a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span></code> (Windows only).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Though it does not produce a <code class="computeroutput"><span class="identifier">utfN_view</span></code>,
          there is a related function <code class="computeroutput">to_string()</code>,
          which takes two UTF-32 iterators and returns a <code class="computeroutput">std::string</code> containing the given
          sequence, UTF-8-encoded.
        </p></td></tr>
</table></div>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><a class="link" href="../../boost/text/utf8_view.html" title="Struct template utf8_view">utf8_view</a></code>,
          <code class="computeroutput"><a class="link" href="../../boost/text/utf16_view.html" title="Struct template utf16_view">utf16_view</a></code>,
          and <code class="computeroutput"><a class="link" href="../../boost/text/utf32_view.html" title="Struct template utf32_view">utf32_view</a></code>
          are all implemented in terms of C++20's <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ranges</span><span class="special">::</span><span class="identifier">view_interface</span></code>.
          Boost.Text uses a pre-C++20-friendly implementation of this from Boost.STLIterfaces
          for pre-C++20 builds. The implication of using <code class="computeroutput"><span class="identifier">view_interface</span></code>
          is that <code class="computeroutput"><a class="link" href="../../boost/text/utf8_view.html" title="Struct template utf8_view">utf8_view</a></code>,
          <code class="computeroutput"><a class="link" href="../../boost/text/utf16_view.html" title="Struct template utf16_view">utf16_view</a></code>,
          and <code class="computeroutput"><a class="link" href="../../boost/text/utf32_view.html" title="Struct template utf32_view">utf32_view</a></code>
          all have the fullest interface possible, based on the iterator and/or sentinel
          template parameters used to instantiate them. For instance, if you use
          a random access iterator to instantiate <code class="computeroutput"><a class="link" href="../../boost/text/utf32_view.html" title="Struct template utf32_view">utf32_view</a></code>, it will have
          an <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>.
          If you use a bidirectional iterator instead, it will not have <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>.
          See <code class="computeroutput"><span class="special">[</span><span class="identifier">view</span><span class="special">.</span><span class="identifier">interface</span><span class="special">]</span></code> in the standard for more details.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h4"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.iterator__quot_unpacking_quot_"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.iterator__quot_unpacking_quot_">Iterator
        "Unpacking"</a>
      </h5>
<p>
        A simple way to represent a transcoding view is as a pair of transcoding
        iterators. However, there is a problem with that approach, since a <code class="computeroutput"><span class="identifier">utf32_view</span><span class="special">&lt;</span><span class="identifier">utf_8_to_32_iterator</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*&gt;&gt;</span></code> would be a range the size of 6 pointers.
        Worse yet, a <code class="computeroutput"><span class="identifier">utf32_view</span><span class="special">&lt;</span><span class="identifier">utf_8_to_16_iterator</span><span class="special">&lt;</span><span class="identifier">utf_16_to_32_iterator</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*&gt;&gt;&gt;</span></code> would be the size of 18 pointers!
        Further, such a view would do a UTF-8 to UTF-16 to UTF-32 conversion, when
        it could have done a direct UTF-8 to UTF-32 conversion instead.
      </p>
<p>
        To solve these kinds of problems, <code class="computeroutput"><span class="identifier">as_utfN</span><span class="special">()</span></code> unpacks the iterators it is given, so that
        only the bottom-most underlying pointer or iterator is stored:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span> <span class="special">=</span> <span class="string">"some text"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="identifier">to_16_first</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_8_to_16_iterator</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">&gt;(</span>
    <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
<span class="keyword">auto</span> <span class="identifier">to_16_last</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_8_to_16_iterator</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">&gt;(</span>
    <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>

<span class="keyword">auto</span> <span class="identifier">to_32_first</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_16_to_32_iterator</span><span class="special">&lt;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_8_to_16_iterator</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">&gt;</span>
<span class="special">&gt;(</span><span class="identifier">to_16_first</span><span class="special">,</span> <span class="identifier">to_16_first</span><span class="special">,</span> <span class="identifier">to_16_last</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">to_32_last</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_16_to_32_iterator</span><span class="special">&lt;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_8_to_16_iterator</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">&gt;</span>
<span class="special">&gt;(</span><span class="identifier">to_16_first</span><span class="special">,</span> <span class="identifier">to_16_last</span><span class="special">,</span> <span class="identifier">to_16_last</span><span class="special">);</span>

<span class="keyword">auto</span> <span class="identifier">range</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_utf8</span><span class="special">(</span><span class="identifier">to_32_first</span><span class="special">,</span> <span class="identifier">to_32_last</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">range</span><span class="special">),</span>
                           <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf8_view</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">&gt;&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
</pre>
<p>
        Each of these views stores only the unpacked iterator and sentinel, so each
        view is typically the size of two pointers, and possibly smaller if a sentinel
        is used.
      </p>
<p>
        The same unpacking logic is used in <code class="computeroutput"><span class="identifier">utfN_iterator</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">from_utfN_inserter</span><span class="special">()</span></code>, the transcoding algorithms, and the normalization
        algorithms. This allows you to write <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_uf32</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">)</span></code> in a generic context, without caring whether
        <code class="computeroutput"><span class="identifier">first</span></code> and <code class="computeroutput"><span class="identifier">last</span></code>
        are iterators to a sequence of UTF-8, UTF-16, or UTF-32. You also do not
        need to care about whether <code class="computeroutput"><span class="identifier">first</span></code>
        and <code class="computeroutput"><span class="identifier">last</span></code> are raw pointers,
        some other kind of iterator, or transcoding iterators. For example, if <code class="computeroutput"><span class="identifier">first</span></code> is a <code class="computeroutput"><a class="link" href="../../boost/text/utf_32_to_8_iterator.html" title="Struct template utf_32_to_8_iterator">utf_32_to_8_iterator</a></code>, the resulting
        view will use <code class="computeroutput"><span class="identifier">first</span><span class="special">.</span><span class="identifier">base</span><span class="special">()</span></code>
        for its begin-iterator.
      </p>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h5"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_algorithms"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.transcoding_algorithms">Transcoding
        Algorithms</a>
      </h5>
<p>
        When you only need to transcode from one UTF encoding to another, use the
        transcoding algorithms instead of the transcoding iterators. The algorithms
        are quite a bit faster in most cases (<code class="computeroutput"><a class="link" href="../../header/boost/text/transcode_algorithm_hpp.html#boost.text.v1.transcode_to_utf3_idm21833">transcode_to_utf32()</a></code>
        is particularly faster when given UTF-8 input, as it uses SIMD instructions
        when available).
      </p>
<p>
        There are three of these, just as there are three make-functions for transcoding
        iterators:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../header/boost/text/transcode_algorithm_hpp.html#boost.text.v1.transcode_to_utf8_idm21701">transcode_to_utf8()</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../header/boost/text/transcode_algorithm_hpp.html#boost.text.v1.transcode_to_utf1_idm21767">transcode_to_utf16()</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../header/boost/text/transcode_algorithm_hpp.html#boost.text.v1.transcode_to_utf3_idm21833">transcode_to_utf32()</a></code>
          </li>
</ul></div>
<p>
        Like the default behavior of the transcoding iterators, these algorithms
        produce the Unicode replacement character <code class="computeroutput"><span class="number">0xFFFD</span></code>
        when encountering an invalid encoding. Unlike the iterators, the algorithms
        are not configurable to handle errors in any other way.
      </p>
<p>
        These are fully generic algorithms, and there are overloads that take iterator-sentinel
        pairs as well as ones that take ranges. Also, the transcode algorithms unpack
        the iterators that they are given, which can be a large optimization. See
        the <a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.iterator__quot_unpacking_quot_">iterator
        unpacking</a> section for details.
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
          Though these algorithms are generic, some of the optimizations in them
          require pointers on both the input and output iterators for maximum performance.
          In performance-critical code paths, stick to pointers.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h6"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.choosing_a_transcoding_mechanism"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.choosing_a_transcoding_mechanism">Choosing
        a Transcoding Mechanism</a>
      </h5>
<p>
        Since there are multiple ways to perform transcoding, how do you pick one?
        Here are some guidelines:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            If you need maximum performance, stick to the transcoding algorithms,
            and in particular use pointers for input and output.
          </li>
<li class="listitem">
            If you need compatibility with existing iterator-based algorithms (such
            as the standard algorithms), use the transcoding iterators.
          </li>
<li class="listitem">
            If you want streamability or the convenience of constructing ranges with
            a single <code class="computeroutput"><span class="identifier">as_utfN</span><span class="special">()</span></code>
            function call, use the transcoding views.
          </li>
</ul></div>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h7"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.accessing_the_underlying_utf_8_chars"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.accessing_the_underlying_utf_8_chars">Accessing
        the Underlying UTF-8 chars</a>
      </h5>
<p>
        When using <code class="computeroutput"><a class="link" href="../../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code> or <code class="computeroutput"><a class="link" href="../../boost/text/utf32_view.html" title="Struct template utf32_view">utf32_view</a></code>,
        it is often desirable to get access to the underlying sequence of <code class="computeroutput"><span class="keyword">char</span></code>s (e.g. for copying into a buffer or constructing
        a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>).
      </p>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code>
        exposes, and in fact all the converting iterators expose, the iterator they
        are parameterized with, via the member function <code class="computeroutput"><span class="identifier">base</span><span class="special">()</span></code>. You can always get at the sequence of
        <code class="computeroutput"><span class="keyword">char</span></code> underlying the code point
        sequence exposed by <code class="computeroutput"><a class="link" href="../../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code> like this:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_8_to_32_iterator</span> <span class="identifier">first</span> <span class="special">=</span> <span class="comment">/* ... */</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_8_to_32_iterator</span> <span class="identifier">last</span> <span class="special">=</span> <span class="comment">/* ... */</span><span class="special">;</span>

<span class="comment">// Copy [first, last) as code points.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">&gt;</span> <span class="identifier">cp_vec</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">cp_vec</span><span class="special">));</span>

<span class="comment">// Copy [first, last) as chars.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">char_vec</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">first</span><span class="special">.</span><span class="identifier">base</span><span class="special">(),</span> <span class="identifier">last</span><span class="special">.</span><span class="identifier">base</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">char_vec</span><span class="special">));</span>
</pre>
<p>
        See the <a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.iterator__quot_unpacking_quot_">iterator
        unpacking</a> section for more detail about how this is used within Boost.Text's
        interfaces.
      </p>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h8"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.the_stream_safe_format"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.the_stream_safe_format">The
        Stream-Safe Format</a>
      </h5>
<p>
        Unicode text often contains sequences in which a noncombining code point
        (e.g. 'A') is followed by one or more combining code points (e.g. some number
        of umlauts). It is valid to have an 'A' followed by 100 million umlauts.
        This is valid but not useful. Unicode specifies something called the <a href="https://unicode.org/reports/tr15/#Stream_Safe_Text_Format" target="_top">Stream-Safe
        Format</a>. This format inserts extra code points between combiners to
        ensure that there are never more than 30 combiners in a row. In practice,
        you should never need anywhere near 30.
      </p>
<p>
        Boost.Text provides an API for putting text in a <a href="https://unicode.org/reports/tr15/#Stream_Safe_Text_Format" target="_top">Stream-Safe
        Format</a>:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">&gt;</span> <span class="identifier">code_points</span> <span class="special">=</span> <span class="comment">/* ... */</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">stream_safe</span><span class="special">(</span><span class="identifier">code_points</span><span class="special">);</span>
<span class="identifier">code_points</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">it</span><span class="special">.</span><span class="identifier">base</span><span class="special">(),</span> <span class="identifier">code_points</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">is_safe_stream</span><span class="special">(</span><span class="identifier">code_points</span><span class="special">));</span>
</pre>
<p>
        There is also a view API:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">&gt;</span> <span class="identifier">code_points</span> <span class="special">=</span> <span class="comment">/* ... */</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">stream_safe_view</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_stream_safe</span><span class="special">(</span><span class="identifier">code_points</span><span class="special">);</span>
</pre>
<p>
        These operations do not implement the <a href="https://unicode.org/reports/tr15/#Stream_Safe_Text_Format" target="_top">Stream-Safe
        Format</a> algorithm described on the Unicode web site. Instead, it takes
        the much simpler approach of allowing only at most 8 combiners after any
        noncombiner. The rest are truncated.
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">
<p>
          Long sequences of combining characters create a problem for algorithms
          like normalization or grapheme breaking; the grapheme breaking algorithm
          may be required to look ahead a very long way in order to determine how
          to handle the current grapheme. To address this, Unicode allows a conforming
          implementation to assume that a sequence of code points contains graphemes
          of at most 32 code points. This is known as the <a href="https://unicode.org/reports/tr15/#Stream_Safe_Text_Format" target="_top">Stream-Safe
          Format</a> assumption; Boost.Text makes this assumption.
        </p>
<p>
          If you give Boost.Text algorithms a code point sequence with graphemes
          longer than 32 code points, you will get undefined behavior. This poses
          a security problem. To address this, use the stream-safe API (e.g. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">as_stream_safe</span><span class="special">()</span></code>),
          or use the container-modifying free functions to normalize, render stream-safe,
          and erase/insert/replace in one call. See the <a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.container_modifying_normalization_api">Container-Modifying
          Normalization API</a> section for details.
        </p>
</td></tr>
</table></div>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h9"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.normalization"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.normalization">Normalization</a>
      </h5>
<p>
        Boost.Text provides algorithms for all four Unicode normalization forms:
        NFD, NFKD, NFC, and NFKC. In addition, it provides an unofficial fifth normalization
        form called FCC that is described in <a href="https://unicode.org/notes/tn5" target="_top">Unicode
        Technical Note #5</a>. FCC is just as compact as the most compact official
        form, NFC, except in a few degenerate cases. FCC is particularly useful when
        doing collation &#8212; the collation algorithm requires its inputs to be
        normalized NFD or FCC, and FCC is much faster to normalize to.
      </p>
<p>
        The algorithm is invoked as <code class="computeroutput"><span class="identifier">normalize</span><span class="special">&lt;</span><span class="identifier">X</span><span class="special">&gt;()</span></code>,
        where <code class="computeroutput"><span class="identifier">X</span></code> is one of the enumerators
        of <code class="computeroutput">nf</code>
        ("Normalization Form"). Range and iterator-based overloads are
        provided. The iterator interfaces require iterators that model <a class="link" href="../concepts.html" title="Concepts"><code class="computeroutput"><span class="identifier">code_point_iter</span></code></a>, and ranges that
        model <a class="link" href="../concepts.html" title="Concepts"><code class="computeroutput"><span class="identifier">code_point_range</span></code></a>.
        There are also algorithms that can check if a code point sequence is in a
        certain normalization form.
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// &#4365;&#4452;&#9676;&#820;&#4526; HANGUL SYLLABLE JJYAE, COMBINING TILDE OVERLAY, HANGUL JONGSEONG TIKEUT</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">,</span> <span class="number">4</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">nfd</span> <span class="special">=</span> <span class="special">{{</span> <span class="number">0x110D</span><span class="special">,</span> <span class="number">0x1164</span><span class="special">,</span> <span class="number">0x0334</span><span class="special">,</span> <span class="number">0x11AE</span> <span class="special">}};</span>
<span class="comment">// Iterator interface.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalized</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">d</span><span class="special">&gt;(</span><span class="identifier">nfd</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">nfd</span><span class="special">.</span><span class="identifier">end</span><span class="special">()));</span>

<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">&gt;</span> <span class="identifier">nfc</span><span class="special">;</span>
    <span class="comment">// Iterator interface.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalize</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">c</span><span class="special">&gt;(</span><span class="identifier">nfd</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">nfd</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">nfc</span><span class="special">));</span>
    <span class="comment">// Range interface.</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalized</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">c</span><span class="special">&gt;(</span><span class="identifier">nfc</span><span class="special">));</span>
<span class="special">}</span>

<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">&gt;</span> <span class="identifier">nfc</span><span class="special">;</span>
    <span class="comment">// Range interface.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalize</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">c</span><span class="special">&gt;(</span><span class="identifier">nfd</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">nfc</span><span class="special">));</span>
    <span class="comment">// Range interface.</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalized</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">c</span><span class="special">&gt;(</span><span class="identifier">nfc</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        There are <code class="computeroutput">std::string</code>-specific
        in-place normalization functions as well, in <a class="link" href="../../header/boost/text/normalize_string_hpp.html" title="Header &lt;boost/text/normalize_string.hpp&gt;">normalize_string.hpp</a>.
      </p>
<p>
        There is also an API for normalizing a code point sequence and appending
        the result to a container:
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// &#4365;&#4452;&#9676;&#820;&#4526; HANGUL SYLLABLE JJYAE, COMBINING TILDE OVERLAY, HANGUL JONGSEONG TIKEUT</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">,</span> <span class="number">4</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">nfd</span> <span class="special">=</span> <span class="special">{{</span> <span class="number">0x110D</span><span class="special">,</span> <span class="number">0x1164</span><span class="special">,</span> <span class="number">0x0334</span><span class="special">,</span> <span class="number">0x11AE</span> <span class="special">}};</span>
<span class="comment">// Iterator interface.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalized</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">d</span><span class="special">&gt;(</span><span class="identifier">nfd</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">nfd</span><span class="special">.</span><span class="identifier">end</span><span class="special">()));</span>

<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">&gt;</span> <span class="identifier">nfc</span><span class="special">;</span>
    <span class="comment">// Iterator interface.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalize</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">c</span><span class="special">&gt;(</span><span class="identifier">nfd</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">nfd</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">nfc</span><span class="special">));</span>
    <span class="comment">// Range interface.</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalized</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">c</span><span class="special">&gt;(</span><span class="identifier">nfc</span><span class="special">));</span>
<span class="special">}</span>

<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">uint32_t</span><span class="special">&gt;</span> <span class="identifier">nfc</span><span class="special">;</span>
    <span class="comment">// Range interface.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalize</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">c</span><span class="special">&gt;(</span><span class="identifier">nfd</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">nfc</span><span class="special">));</span>
    <span class="comment">// Range interface.</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">normalized</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">nf</span><span class="special">::</span><span class="identifier">c</span><span class="special">&gt;(</span><span class="identifier">nfc</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        This is much more performant than the <code class="computeroutput"><span class="identifier">normalize</span><span class="special">()</span></code> function, because the output iterator used
        by <code class="computeroutput"><span class="identifier">normalize</span><span class="special">()</span></code>
        slows things down quite a bit &#8212; <code class="computeroutput"><span class="identifier">normalize</span><span class="special">()</span></code> can be factors slower than <code class="computeroutput"><span class="identifier">normalize_append</span><span class="special">()</span></code>.
        <code class="computeroutput"><span class="identifier">normalize_append</span><span class="special">()</span></code>
        will only append to UTF-8 and UTF-16 containers (UTF-32-encoded containers
        are very uncommon, and so are not supported).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          When you're working entirely within a UTF-8 encoding (on both sides of
          the normalization operation), the most efficient version of the normalization
          API is <code class="computeroutput"><span class="identifier">normalize_append</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
          <span class="identifier">b</span><span class="special">,</span>
          <span class="identifier">str</span><span class="special">)</span></code>,
          where <code class="computeroutput"><span class="identifier">a</span></code> and <code class="computeroutput"><span class="identifier">b</span></code> are iterators over an underlying sequence
          of UTF-8, and <code class="computeroutput"><span class="identifier">str</span></code> is a
          container of integral type <code class="computeroutput"><span class="identifier">T</span></code>,
          where <code class="computeroutput"><span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span> <span class="special">==</span>
          <span class="number">1</span></code>.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.h10"></a>
        <span class="phrase"><a name="boost_text__proposed_.the_unicode_layer.encoding_and_normalization.container_modifying_normalization_api"></a></span><a class="link" href="encoding_and_normalization.html#boost_text__proposed_.the_unicode_layer.encoding_and_normalization.container_modifying_normalization_api">Container-Modifying
        Normalization API</a>
      </h5>
<p>
        If you need to insert text into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
        or other STL-compatible container, you can use the erase/insert/replace API,
        found in <a class="link" href="../../header/boost/text/normalize_algorithm_hpp.html" title="Header &lt;boost/text/normalize_algorithm.hpp&gt;">normalize_algorithm.hpp</a>:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/v1/normalize_erase.html" title="Function template normalize_erase">normalize_erase()</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/v1/normalize_insert_idm19176.html" title="Function template normalize_insert">normalize_insert()</a></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/text/v1/normalize_replace.html" title="Function template normalize_replace">normalize_replace()</a></code>
          </li>
</ul></div>
<p>
        There are iterator and range overloads of each. Each one:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            normalizes the inserted text (if text is being inserted);
          </li>
<li class="listitem">
            places the inserted text in <a href="https://unicode.org/reports/tr15/#Stream_Safe_Text_Format" target="_top">Stream-Safe
            Format</a> (if text is being inserted);
          </li>
<li class="listitem">
            performs the erase/insert/replace operation on the string;
          </li>
<li class="listitem">
            ensures that the result is in <a href="https://unicode.org/reports/tr15/#Stream_Safe_Text_Format" target="_top">Stream-Safe
            Format</a> (if text is being erased); and
          </li>
<li class="listitem">
            normalizes the code points on either side of the affected subsequence
            within the string.
          </li>
</ul></div>
<p>
        This last step is necessary because insertions and erasures may create situations
        in which code points which may combine are now next to each other, when they
        were not before.
      </p>
<p>
        This API is like the <code class="computeroutput"><span class="identifier">normalize_append</span><span class="special">()</span></code> overloads in that it may operate on UTF-8
        or UTF-16 containers, and deduces the UTF from the size of the mutated container's
        <code class="computeroutput"><span class="identifier">value_type</span></code>.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../the_unicode_layer.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../the_unicode_layer.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="text_segmentation.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
