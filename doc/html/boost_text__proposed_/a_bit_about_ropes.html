<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>A Bit About Ropes</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="prev" href="the_unicode_layer/string_algorithms_and_utilities.html" title="String Algorithms and Utilities">
<link rel="next" href="the_text_layer.html" title="The Text Layer">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="the_unicode_layer/string_algorithms_and_utilities.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="the_text_layer.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_text__proposed_.a_bit_about_ropes"></a><a class="link" href="a_bit_about_ropes.html" title="A Bit About Ropes">A Bit About Ropes</a>
</h2></div></div></div>
<p>
      In general, a <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_top">Rope</a>
      is a heavyweight string; whereas a string is a simple array of contiguous storage,
      a <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_top">Rope</a>
      is much more complicated and is typically a tree whose leaves are contiguous
      strings.
    </p>
<p>
      Boost.Text has three rope types: <code class="computeroutput"><a class="link" href="../boost/text/segmented_vector.html" title="Struct template segmented_vector">segmented_vector</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>,
      and <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>.
      <code class="computeroutput"><a class="link" href="../boost/text/segmented_vector.html" title="Struct template segmented_vector">segmented_vector</a></code>
      is not a proper rope, in that it is intended for non-character element types.
      <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>
      is part of the Boost.Text's <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code> layer, and so deals with
      Unicode quite a bit. To keep things simple, the discussion below sticks to
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>.
      Everything described there applies to <code class="computeroutput"><a class="link" href="../boost/text/segmented_vector.html" title="Struct template segmented_vector">segmented_vector</a></code> and <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>
      too, of course.
    </p>
<p>
      The user's view of Boost.Text's <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code> is that it is
      a string that is inexpensive to insert into at any point -- even the middle
      or front -- no matter how large it is. In addition, substrings within the
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>
      have copy-on-write semantics. This means that often a copy of a very large
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>
      is nearly free, and that a mutated copy of an <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code> often shares much
      of its data with the <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code> from which it
      was copied.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>'s
      implementation uses a tree structure similar to a B-tree, and each subtree
      is copy-on-write. The tree consists of interior nodes that contain structural
      information, and leaf nodes which contain the data. <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code> only contains
      a single pointer to a root node. Here is one of the simplest nonempty <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_ropes</a></code>
      you can have:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_text_leaf.svg" width="160" height="144"></object></span>
    </p>
<p>
      This <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>
      is just a single leaf node, containing the super-useful string <code class="computeroutput"><span class="string">"text"</span></code>. In this case, the leaf was
      a <code class="computeroutput">std::string</code>
      node, labeled here with <code class="computeroutput"><span class="identifier">s</span></code>.
      There can also be nodes that are references to <code class="computeroutput">std::string</code>
      nodes, labeled as <code class="computeroutput"><span class="identifier">ref</span></code>. More
      on that in a bit.
    </p>
<p>
      If we copy the <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>
      above, we get something like this:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_text_leaf_extra_ref.svg" width="202" height="143"></object></span>
    </p>
<p>
      No copying was done, nor allocations performed. Copying an entire tree only
      requires copying a pointer and incrementing a reference count. The string in
      this <code class="computeroutput">std::string</code>
      leaf is only four elements, but let's suppose it was megabytes instead. Inserting
      even a small sequence near the beginning of the string would be costly, since
      we'd have to copy all the elements after the insertion point. And since the
      <code class="computeroutput">std::string</code>
      leaf may be shared, we would have to copy everything <span class="emphasis"><em>before</em></span>
      the insertion, too! For large <code class="computeroutput">std::string</code>
      leaves, insertions into them result in something like this:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_text_refs_after_insert.svg" width="534" height="242"></object></span>
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        This is <span class="bold"><strong>not</strong></span> what actually happens to small
        <code class="computeroutput">std::string</code>
        leaves with a reference count of 1! Those are mutated in place.
      </p></td></tr>
</table></div>
<p>
      Here, we see that we've made two new reference nodes, each of which refers
      to part of the original <code class="computeroutput">std::string</code>,
      and we've put the inserted string in between, forming <code class="computeroutput"><span class="string">"text
      text"</span></code>, the <span class="bold"><strong>best</strong></span> string.
    </p>
<p>
      And now we see our first interior node. Each interior node has a key and a
      pointer for each child, and a fixed maximum number of children. Each key <code class="computeroutput"><span class="identifier">Ki</span></code> is the cumulative size of all children
      in the range <code class="computeroutput"><span class="special">[</span><span class="number">0</span><span class="special">,</span> <span class="identifier">i</span><span class="special">]</span></code>.
    </p>
<p>
      To make the images smaller, each interior node in these diagrams has a maximum
      of four children (the actual number is an implementation detail, but it's a
      lot higher).
    </p>
<p>
      Now let's take a look at a more complicated <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_tree_structure.svg" width="748" height="363"></object></span>
    </p>
<p>
      In this tree, we have three interior nodes: the root and its two children.
      We also have at least one of each type of leaf node.
    </p>
<p>
      Copying even this <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code> is very cheap,
      requiring only copying a pointer and incriminating a reference count:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_copy_add_ref.svg" width="748" height="363"></object></span>
    </p>
<p>
      Let's say we wanted to erase part of this <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>. We'll erase a
      substring that matches a whole leaf exactly, to keep things simpler. Let's
      erase the <code class="computeroutput"><span class="identifier">ref</span></code> node on the left:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_erase.svg" width="878" height="363"></object></span>
    </p>
<p>
      Simple, right? In this case, we did the erasure by creating a copy of each
      node on the path from the root to the erased <code class="computeroutput"><span class="identifier">ref</span></code>
      leaf, and just referring to all the other nodes that did not change. Again,
      most of the string data and even interior nodes are shared among the three
      ropes in the diagram. This same principle applies to <code class="computeroutput"><span class="identifier">insert</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">erase</span><span class="special">()</span></code>, and <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code>.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        We don't make new nodes every time we need to do an insert, erase, or other
        mutation. If the reference counts on the root-to-leaf path are all <code class="computeroutput"><span class="number">1</span></code>, we will mutate the tree in place.
      </p></td></tr>
</table></div>
<p>
      Besides the segmented nature of <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>, there are some
      other properties you need to know about. An <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code> as a whole is
      copy-on-write; it is also therefore thread-safe for reading and writing; it
      is not null-terminated.
    </p>
<p>
      Insertions, erasures, and indexing each happen in <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">log_B</span><span class="special">(</span><span class="identifier">N</span><span class="special">))</span></code> time,
      where B is the branching factor (maximum number of children per interior node).
      As mentioned before, B is an implementation detail, and thus subject to change,
      but it is unlikely to be less than 16. That means very little pointer chasing
      is required to access an arbitrary element of an <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>, because its tree
      is very shallow.
    </p>
<p>
      In fact, with a branching factor of 16, the maximum depth of the tree is also
      16, since the <code class="computeroutput"><span class="identifier">max_size</span><span class="special">()</span></code>
      of the tree is <code class="computeroutput"><span class="identifier">PTRDIFF_MAX</span></code>.
      This means that <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">log_B</span><span class="special">(</span><span class="identifier">N</span><span class="special">))</span></code> time has a fixed upper bound, making it
      <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code>!
    </p>
<p>
      As mentioned previously, mutations to an <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code> are done in-place
      if the mutations do not affect nodes that are shared with other <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_ropes</a></code>.
    </p>
<p>
      If a mutation can be done in place, and the point of mutation falls within
      a <code class="computeroutput">std::string</code>
      leaf, the <code class="computeroutput">std::string</code>
      object is directly mutated if: the inserted string fits within the <code class="computeroutput"><span class="identifier">capacity</span><span class="special">()</span></code>
      of the <code class="computeroutput">std::string</code>,
      <span class="bold"><strong>or</strong></span>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          the <code class="computeroutput">std::string</code>
          object is not too large (there is a maximum size that is an implementation
          detail, but is likely to be hundreds or thousands, not tens or tens of
          thousands), <span class="bold"><strong>and</strong></span>
        </li>
<li class="listitem">
          the inserted object would cause an allocation if copied (i.e. it is a
          <code class="computeroutput">std::string</code>).
        </li>
</ul></div>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
        One more thing. <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_ropes</a></code> are meant to
        be passed by value. In particular, their thread-safety guarantees might not
        be fulfilled if they are <span class="bold"><strong>not</strong></span> passed by value
        across thread boundaries. If you do not care about thread-safe use of <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>,
        you can pass <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_ropes</a></code>
        by <code class="computeroutput"><span class="keyword">const</span> <span class="special">&amp;</span></code>
        at thread boundaries if you like. If you care about thread-safety, <span class="bold"><strong>always</strong></span> pass them by value at thread boundaries!
      </p></td></tr>
</table></div>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>
      contains logic like the pseudocode below to determine when to create a partial
      copy of an <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>'s
      tree, or when to mutate the tree in-place when performing inserts or erases
      on an <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>:
    </p>
<pre class="programlisting"><span class="identifier">path</span> <span class="special">=</span> <span class="identifier">find_path_from_root_to_mutation_point</span><span class="special">()</span>
<span class="identifier">in_place</span> <span class="special">=</span> <span class="keyword">true</span>
<span class="keyword">for</span> <span class="special">(</span><span class="identifier">node</span> <span class="special">:</span> <span class="identifier">path</span><span class="special">)</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">node</span><span class="special">.</span><span class="identifier">references</span><span class="special">()</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span>
        <span class="identifier">in_place</span> <span class="special">=</span> <span class="keyword">false</span>
</pre>
<p>
      Let's call the <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>
      <code class="computeroutput"><span class="identifier">R</span></code>, and the thread on which
      the operation is being performed <code class="computeroutput"><span class="identifier">T</span></code>.
      Also, assume that all references to <code class="computeroutput"><span class="identifier">R</span></code>'s
      root node exist in copies of <code class="computeroutput"><span class="identifier">R</span></code>,
      and no reference (C++ reference/pointer) to <code class="computeroutput"><span class="identifier">R</span></code>
      or any of its copies exists.
    </p>
<p>
      With this assumption, we know at the end of the pseudocode <code class="computeroutput"><span class="keyword">for</span></code>
      loop above, that there is still exactly one reference to each node in <code class="computeroutput"><span class="identifier">path</span></code>. For this not to be true, we would need
      to either:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          Create a copy of one of the nodes on thread <code class="computeroutput"><span class="identifier">T</span></code>.
          Clearly we cannot, since we're currently executing <code class="computeroutput"><span class="identifier">insert</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">erase</span><span class="special">()</span></code> instead.
        </li>
<li class="listitem">
          Create a copy of one of the nodes on a thread other than <code class="computeroutput"><span class="identifier">T</span></code>. We can't do this either, since we
          have no reference to <code class="computeroutput"><span class="identifier">R</span></code>
          that can be used by another thread, and we know that there are no other
          copies on any other threads either &#8212; since each node's reference
          count is <code class="computeroutput"><span class="number">1</span></code>.
        </li>
</ol></div>
<p>
      Were we to write references/pointers to <code class="computeroutput"><span class="identifier">R</span></code>
      into our code, a thread other than <code class="computeroutput"><span class="identifier">T</span></code>
      could create a copy of <code class="computeroutput"><span class="identifier">R</span></code> between
      when we read the reference count of one of its nodes, and when we decided to
      mutate <code class="computeroutput"><span class="identifier">R</span></code> in place or not.
    </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
        Therefore, if you care about using <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_ropes</a></code> in a thread-safe
        manner, always pass them by value across thread boundaries.
      </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        A major use case for <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_ropes</a></code> is for building
        undo/redo systems for text editing that are simple and performant. See the
        example in the <a class="link" href="segmented_vector_.html" title="segmented_vector"><code class="computeroutput"><span class="identifier">segmented_vector</span></code> documentation</a> for
        details &#8212; just imagine <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_ropes</a></code> instead of
        <code class="computeroutput"><span class="identifier">segmented_vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>s.
      </p></td></tr>
</table></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="the_unicode_layer/string_algorithms_and_utilities.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="the_text_layer.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
